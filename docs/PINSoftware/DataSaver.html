<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>PINSoftware.DataSaver API documentation</title>
<meta name="description" content="This file is somewhat similar to `PINSoftware.DashComponents` in that there are a few support
definitions and then two implementations of the same …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PINSoftware.DataSaver</code></h1>
</header>
<section id="section-intro">
<p>This file is somewhat similar to <code><a title="PINSoftware.DashComponents" href="DashComponents.html">PINSoftware.DashComponents</a></code> in that there are a few support
definitions and then two implementations of the same thing along with a base class they both
inherit from and which sets a common interface. A <code><a title="PINSoftware.DataSaver" href="#PINSoftware.DataSaver">PINSoftware.DataSaver</a></code> here is an object
whose instance runs in a separate thread and periodically checks the
<code><a title="PINSoftware.DataAnalyser.DataAnalyser" href="DataAnalyser.html#PINSoftware.DataAnalyser.DataAnalyser">DataAnalyser</a></code> for new data and then saves it.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This file is somewhat similar to `PINSoftware.DashComponents` in that there are a few support
definitions and then two implementations of the same thing along with a base class they both
inherit from and which sets a common interface. A `PINSoftware.DataSaver` here is an object
whose instance runs in a separate thread and periodically checks the
`PINSoftware.DataAnalyser.DataAnalyser` for new data and then saves it.
&#34;&#34;&#34;
import datetime
import threading
import time

from os import path
from enum import Enum
from typing import List

import h5py

from PINSoftware.DataAnalyser import DataAnalyser


class Filetype(Enum):
    &#34;&#34;&#34;An enum to get the possible saving options reliably&#34;&#34;&#34;
    Csv = 0
    Hdf5 = 1

    def get_ext(self):
        &#34;&#34;&#34;Returns the appropriate file extension for the file type&#34;&#34;&#34;
        if self == Filetype.Csv:
            return &#34;csv&#34;
        else:
            return &#34;hdf5&#34;

    @staticmethod
    def from_str(string):
        &#34;&#34;&#34;A static method to get a `Filetype` from a string, it may return None if the string invalid&#34;&#34;&#34;
        if string == &#34;csv&#34;:
            return Filetype.Csv
        elif string == &#34;hdf5&#34;:
            return Filetype.Hdf5
        else:
            return None

class SavingException(Exception):
    &#34;&#34;&#34;A general exception to be raised when an error occurred during saving&#34;&#34;&#34;
    pass

class BaseDataSaver(threading.Thread):
    &#34;&#34;&#34;
    This class creates a common interface for all `PINSoftware.DataSaver`s. A new saver
    should inherit from this class and override the `BaseDataSaver.do_single_save` method
    to something which does the saving action itself. It can also possibly override the
    `BaseDataSaver.close` method which is called on ending the saving (usually you may want
    to close the file objects there).
    &#34;&#34;&#34;
    def __init__(self, data : DataAnalyser, full_filename : str, save_interval : float = 1):
        &#34;&#34;&#34;
        `data` is the `PINSoftware.DataAnalyser.DataAnalyser` from which the data should be saved.

        `full_filename` is the full path to the file where the data should be saved (with the extension).

        `save_interval` is the interval in which the `PINSoftware.DataSaver` should check for new data.
        &#34;&#34;&#34;
        super().__init__()
        self.should_stop = False
        self.data = data
        self.debugger = self.data.debugger
        self.full_filename = full_filename
        self.save_interval = save_interval

    def do_single_save(self):
        &#34;&#34;&#34;
        This method should be overridden. This method should check for new data
        and save it.
        &#34;&#34;&#34;
        pass

    def close(self):
        &#34;&#34;&#34;This method may be overridden, it is called at the end of saving&#34;&#34;&#34;
        pass
    
    def run(self):
        &#34;&#34;&#34;This method is called when `BaseDataSaver.start` is called, it is the main loop&#34;&#34;&#34;
        self.debugger.info(&#34;BaseDataSaver: Starting&#34;)
        next_call = time.time()
        while not self.should_stop:
            next_call += self.save_interval
            time.sleep(max(0, next_call - time.time()))
            self.do_single_save()
        self.close()
        self.debugger.info(&#34;BaseDataSaver: Stopped successfully&#34;)

    def stop(self):
        &#34;&#34;&#34;This is a simple setter, it is here to be analogous with the way the thread was started (`BaseDataSaver.start`)&#34;&#34;&#34;
        self.should_stop = True

class CsvDataSaver(BaseDataSaver):
    &#34;&#34;&#34;
    This is a very simple `PINSoftware.DataSaver` with very few options. It saves the peak voltages
    (`PINSoftware.DataAnalyser.DataAnalyser.processed`) along with their timestamps in a csv file.
    The csv file format doesn&#39;t allow for storing multiple unrelated data easily so this is all.
    &#34;&#34;&#34;
    def __init__(self, data : DataAnalyser, save_folder : str, save_base_filename : str, **kwargs):
        &#34;&#34;&#34;
        Everything except `save_folder` and `save_base_filename` is passed to the `BaseDataSaver`.
        `save_folder` and `save_base_filename` are combined along with a timestamp into the
        `full_filename` which is passed to `BaseDataSaver`. An attempt is also made to open the file,
        if it fails `SavingException` is raised.
        &#34;&#34;&#34;
        full_filename = path.join(save_folder, save_base_filename + datetime.datetime.now().strftime(&#34;%y%m%d-%H%M%S&#34;) + &#34;.csv&#34;)
        super().__init__(data, full_filename, **kwargs)
        try:
            self.csv_file = open(full_filename, &#39;w&#39;)
            self.debugger.info(&#34;CsvDataSaver: Successfully created csv file \&#34;&#34; + full_filename + &#34;\&#34;&#34;)
            self.csv_file.write(&#34;timestamps,processed_ys\n&#34;)
        except:
            raise SavingException(&#34;Could not open file \&#34;&#34; + full_filename + &#34;\&#34; to log data in.&#34;)
        self.index = 0

    def do_single_save(self):
        &#34;&#34;&#34;.&#34;&#34;&#34;
        new_index = len(self.data.processed_ys)
        for pro_y, pro_times in zip(self.data.processed_ys[self.index:], self.data.processed_timestamps[self.index:]):
            self.csv_file.write(str(pro_times) + &#34;,&#34; + str(pro_y) + &#34;\n&#34;)
        self.index = new_index

    def close(self):
        &#34;&#34;&#34;.&#34;&#34;&#34;
        self.do_single_save()
        self.csv_file.close()

class Hdf5DataSaver(BaseDataSaver):
    &#34;&#34;&#34;
    This is the main saver, it can save all the data in an hdf5 file. The processing parameters are saved as
    attributes. It it possible to choose what data is saved using the `items` argument.
    &#34;&#34;&#34;
    def __init__(self, data : DataAnalyser, save_folder : str, save_base_filename : str, items : List[str], **kwargs):
        &#34;&#34;&#34;
        `data` and `kwargs` are passed to `BaseDataSaver`.

        `save_folder` and `save_base_filename` are combined along with a timestamp and extension to form the
        `full_filename`. The file is them opened, if that failed a `SavingException` is raised.

        `items` determine what data gets saved. It is a list of strings and if certain strings are in there,
        some data gets saved. If it contains &#34;ys&#34; raw data gets saved, &#34;processed_ys&#34; means peak voltages
        along with their timestamps, &#34;averaged_processed_ys&#34; means averaged peak voltages and their timestamps.
        Finally &#34;markers&#34; means markers and their timestamps.
        &#34;&#34;&#34;
        full_filename = path.join(save_folder, save_base_filename + datetime.datetime.now().strftime(&#34;%y%m%d-%H%M%S&#34;) + &#34;.hdf5&#34;)
        super().__init__(data, full_filename, **kwargs)
        try:
            self.hdf_file = h5py.File(full_filename, &#39;w&#39;)
            self.debugger.info(&#34;Hdf5DataSaver: Successfully created hdf5 file \&#34;&#34; + full_filename + &#34;\&#34;&#34;)

            self.hdf_file.attrs[&#39;freq&#39;] = self.data.freq
            self.hdf_file.attrs[&#39;edge_detection_threshold&#39;] = self.data.edge_detection_threshold
            self.hdf_file.attrs[&#39;average_count&#39;] = self.data.average_count

            self.hdf_datasets = []
            self.indices = []
            self.data_sources = []

            if &#34;ys&#34; in items:
                self.hdf_datasets.append(self.hdf_file.create_dataset(&#34;ys&#34;, (0,), chunks=True, maxshape=(None,), dtype=&#39;f4&#39;))
                self.indices.append(0)
                self.data_sources.append(self.data.ys)
            if &#34;processed_ys&#34; in items:
                self.hdf_datasets.append(self.hdf_file.create_dataset(&#34;processed_ys&#34;, (0,), chunks=True, maxshape=(None,), dtype=&#39;f4&#39;))
                self.hdf_datasets.append(self.hdf_file.create_dataset(&#34;processed_timestamps&#34;, (0,), chunks=True, maxshape=(None,), dtype=&#39;f8&#39;))
                self.indices.append(0)
                self.indices.append(0)
                self.data_sources.append(self.data.processed_ys)
                self.data_sources.append(self.data.processed_timestamps)
            if &#34;averaged_processed_ys&#34; in items:
                self.hdf_datasets.append(self.hdf_file.create_dataset(&#34;averaged_processed_ys&#34;, (0,), chunks=True, maxshape=(None,), dtype=&#39;f4&#39;))
                self.hdf_datasets.append(self.hdf_file.create_dataset(&#34;averaged_processed_timestamps&#34;, (0,), chunks=True, maxshape=(None,), dtype=&#39;f8&#39;))
                self.indices.append(0)
                self.indices.append(0)
                self.data_sources.append(self.data.averaged_processed_ys)
                self.data_sources.append(self.data.averaged_processed_timestamps)
            if &#34;markers&#34; in items:
                self.hdf_datasets.append(self.hdf_file.create_dataset(&#34;markers&#34;, (0,), chunks=True, maxshape=(None,), dtype=&#39;f4&#39;))
                self.hdf_datasets.append(self.hdf_file.create_dataset(&#34;marker_timestamps&#34;, (0,), chunks=True, maxshape=(None,), dtype=&#39;f8&#39;))
                self.indices.append(0)
                self.indices.append(0)
                self.data_sources.append(self.data.markers)
                self.data_sources.append(self.data.marker_timestamps)
        except:
            raise SavingException(&#34;Could not open file \&#34;&#34; + full_filename + &#34;\&#34; to log data in.&#34;)

    def do_single_save(self):
        &#34;&#34;&#34;.&#34;&#34;&#34;
        new_indices = [len(source) for source in self.data_sources]
        for dataset, index, source, new_index in zip(self.hdf_datasets, self.indices, self.data_sources, new_indices):
            dataset.resize((new_index,))
            dataset[index:new_index] = source[index:new_index]
        self.indices = new_indices

    def close(self):
        &#34;&#34;&#34;.&#34;&#34;&#34;
        self.hdf_file.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="PINSoftware.DataSaver.Filetype"><code class="flex name class">
<span>class <span class="ident">Filetype</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enum to get the possible saving options reliably</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Filetype(Enum):
    &#34;&#34;&#34;An enum to get the possible saving options reliably&#34;&#34;&#34;
    Csv = 0
    Hdf5 = 1

    def get_ext(self):
        &#34;&#34;&#34;Returns the appropriate file extension for the file type&#34;&#34;&#34;
        if self == Filetype.Csv:
            return &#34;csv&#34;
        else:
            return &#34;hdf5&#34;

    @staticmethod
    def from_str(string):
        &#34;&#34;&#34;A static method to get a `Filetype` from a string, it may return None if the string invalid&#34;&#34;&#34;
        if string == &#34;csv&#34;:
            return Filetype.Csv
        elif string == &#34;hdf5&#34;:
            return Filetype.Hdf5
        else:
            return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="PINSoftware.DataSaver.Filetype.Csv"><code class="name">var <span class="ident">Csv</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="PINSoftware.DataSaver.Filetype.Hdf5"><code class="name">var <span class="ident">Hdf5</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="PINSoftware.DataSaver.SavingException"><code class="flex name class">
<span>class <span class="ident">SavingException</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>A general exception to be raised when an error occurred during saving</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SavingException(Exception):
    &#34;&#34;&#34;A general exception to be raised when an error occurred during saving&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="PINSoftware.DataSaver.BaseDataSaver"><code class="flex name class">
<span>class <span class="ident">BaseDataSaver</span></span>
<span>(</span><span>data: <a title="PINSoftware.DataAnalyser.DataAnalyser" href="DataAnalyser.html#PINSoftware.DataAnalyser.DataAnalyser">DataAnalyser</a>, full_filename: str, save_interval: float = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>This class creates a common interface for all <code><a title="PINSoftware.DataSaver" href="#PINSoftware.DataSaver">PINSoftware.DataSaver</a></code>s. A new saver
should inherit from this class and override the <code><a title="PINSoftware.DataSaver.BaseDataSaver.do_single_save" href="#PINSoftware.DataSaver.BaseDataSaver.do_single_save">BaseDataSaver.do_single_save()</a></code> method
to something which does the saving action itself. It can also possibly override the
<code><a title="PINSoftware.DataSaver.BaseDataSaver.close" href="#PINSoftware.DataSaver.BaseDataSaver.close">BaseDataSaver.close()</a></code> method which is called on ending the saving (usually you may want
to close the file objects there).</p>
<p><code>data</code> is the <code><a title="PINSoftware.DataAnalyser.DataAnalyser" href="DataAnalyser.html#PINSoftware.DataAnalyser.DataAnalyser">DataAnalyser</a></code> from which the data should be saved.</p>
<p><code>full_filename</code> is the full path to the file where the data should be saved (with the extension).</p>
<p><code>save_interval</code> is the interval in which the <code><a title="PINSoftware.DataSaver" href="#PINSoftware.DataSaver">PINSoftware.DataSaver</a></code> should check for new data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseDataSaver(threading.Thread):
    &#34;&#34;&#34;
    This class creates a common interface for all `PINSoftware.DataSaver`s. A new saver
    should inherit from this class and override the `BaseDataSaver.do_single_save` method
    to something which does the saving action itself. It can also possibly override the
    `BaseDataSaver.close` method which is called on ending the saving (usually you may want
    to close the file objects there).
    &#34;&#34;&#34;
    def __init__(self, data : DataAnalyser, full_filename : str, save_interval : float = 1):
        &#34;&#34;&#34;
        `data` is the `PINSoftware.DataAnalyser.DataAnalyser` from which the data should be saved.

        `full_filename` is the full path to the file where the data should be saved (with the extension).

        `save_interval` is the interval in which the `PINSoftware.DataSaver` should check for new data.
        &#34;&#34;&#34;
        super().__init__()
        self.should_stop = False
        self.data = data
        self.debugger = self.data.debugger
        self.full_filename = full_filename
        self.save_interval = save_interval

    def do_single_save(self):
        &#34;&#34;&#34;
        This method should be overridden. This method should check for new data
        and save it.
        &#34;&#34;&#34;
        pass

    def close(self):
        &#34;&#34;&#34;This method may be overridden, it is called at the end of saving&#34;&#34;&#34;
        pass
    
    def run(self):
        &#34;&#34;&#34;This method is called when `BaseDataSaver.start` is called, it is the main loop&#34;&#34;&#34;
        self.debugger.info(&#34;BaseDataSaver: Starting&#34;)
        next_call = time.time()
        while not self.should_stop:
            next_call += self.save_interval
            time.sleep(max(0, next_call - time.time()))
            self.do_single_save()
        self.close()
        self.debugger.info(&#34;BaseDataSaver: Stopped successfully&#34;)

    def stop(self):
        &#34;&#34;&#34;This is a simple setter, it is here to be analogous with the way the thread was started (`BaseDataSaver.start`)&#34;&#34;&#34;
        self.should_stop = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>threading.Thread</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="PINSoftware.DataSaver.CsvDataSaver" href="#PINSoftware.DataSaver.CsvDataSaver">CsvDataSaver</a></li>
<li><a title="PINSoftware.DataSaver.Hdf5DataSaver" href="#PINSoftware.DataSaver.Hdf5DataSaver">Hdf5DataSaver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="PINSoftware.DataSaver.BaseDataSaver.do_single_save"><code class="name flex">
<span>def <span class="ident">do_single_save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method should be overridden. This method should check for new data
and save it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_single_save(self):
    &#34;&#34;&#34;
    This method should be overridden. This method should check for new data
    and save it.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="PINSoftware.DataSaver.BaseDataSaver.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method may be overridden, it is called at the end of saving</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;This method may be overridden, it is called at the end of saving&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="PINSoftware.DataSaver.BaseDataSaver.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is called when <code>BaseDataSaver.start</code> is called, it is the main loop</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;This method is called when `BaseDataSaver.start` is called, it is the main loop&#34;&#34;&#34;
    self.debugger.info(&#34;BaseDataSaver: Starting&#34;)
    next_call = time.time()
    while not self.should_stop:
        next_call += self.save_interval
        time.sleep(max(0, next_call - time.time()))
        self.do_single_save()
    self.close()
    self.debugger.info(&#34;BaseDataSaver: Stopped successfully&#34;)</code></pre>
</details>
</dd>
<dt id="PINSoftware.DataSaver.BaseDataSaver.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a simple setter, it is here to be analogous with the way the thread was started (<code>BaseDataSaver.start</code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    &#34;&#34;&#34;This is a simple setter, it is here to be analogous with the way the thread was started (`BaseDataSaver.start`)&#34;&#34;&#34;
    self.should_stop = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="PINSoftware.DataSaver.CsvDataSaver"><code class="flex name class">
<span>class <span class="ident">CsvDataSaver</span></span>
<span>(</span><span>data: <a title="PINSoftware.DataAnalyser.DataAnalyser" href="DataAnalyser.html#PINSoftware.DataAnalyser.DataAnalyser">DataAnalyser</a>, save_folder: str, save_base_filename: str, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a very simple <code><a title="PINSoftware.DataSaver" href="#PINSoftware.DataSaver">PINSoftware.DataSaver</a></code> with very few options. It saves the peak voltages
(<code>PINSoftware.DataAnalyser.DataAnalyser.processed</code>) along with their timestamps in a csv file.
The csv file format doesn't allow for storing multiple unrelated data easily so this is all.</p>
<p>Everything except <code>save_folder</code> and <code>save_base_filename</code> is passed to the <code><a title="PINSoftware.DataSaver.BaseDataSaver" href="#PINSoftware.DataSaver.BaseDataSaver">BaseDataSaver</a></code>.
<code>save_folder</code> and <code>save_base_filename</code> are combined along with a timestamp into the
<code>full_filename</code> which is passed to <code><a title="PINSoftware.DataSaver.BaseDataSaver" href="#PINSoftware.DataSaver.BaseDataSaver">BaseDataSaver</a></code>. An attempt is also made to open the file,
if it fails <code><a title="PINSoftware.DataSaver.SavingException" href="#PINSoftware.DataSaver.SavingException">SavingException</a></code> is raised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CsvDataSaver(BaseDataSaver):
    &#34;&#34;&#34;
    This is a very simple `PINSoftware.DataSaver` with very few options. It saves the peak voltages
    (`PINSoftware.DataAnalyser.DataAnalyser.processed`) along with their timestamps in a csv file.
    The csv file format doesn&#39;t allow for storing multiple unrelated data easily so this is all.
    &#34;&#34;&#34;
    def __init__(self, data : DataAnalyser, save_folder : str, save_base_filename : str, **kwargs):
        &#34;&#34;&#34;
        Everything except `save_folder` and `save_base_filename` is passed to the `BaseDataSaver`.
        `save_folder` and `save_base_filename` are combined along with a timestamp into the
        `full_filename` which is passed to `BaseDataSaver`. An attempt is also made to open the file,
        if it fails `SavingException` is raised.
        &#34;&#34;&#34;
        full_filename = path.join(save_folder, save_base_filename + datetime.datetime.now().strftime(&#34;%y%m%d-%H%M%S&#34;) + &#34;.csv&#34;)
        super().__init__(data, full_filename, **kwargs)
        try:
            self.csv_file = open(full_filename, &#39;w&#39;)
            self.debugger.info(&#34;CsvDataSaver: Successfully created csv file \&#34;&#34; + full_filename + &#34;\&#34;&#34;)
            self.csv_file.write(&#34;timestamps,processed_ys\n&#34;)
        except:
            raise SavingException(&#34;Could not open file \&#34;&#34; + full_filename + &#34;\&#34; to log data in.&#34;)
        self.index = 0

    def do_single_save(self):
        &#34;&#34;&#34;.&#34;&#34;&#34;
        new_index = len(self.data.processed_ys)
        for pro_y, pro_times in zip(self.data.processed_ys[self.index:], self.data.processed_timestamps[self.index:]):
            self.csv_file.write(str(pro_times) + &#34;,&#34; + str(pro_y) + &#34;\n&#34;)
        self.index = new_index

    def close(self):
        &#34;&#34;&#34;.&#34;&#34;&#34;
        self.do_single_save()
        self.csv_file.close()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="PINSoftware.DataSaver.BaseDataSaver" href="#PINSoftware.DataSaver.BaseDataSaver">BaseDataSaver</a></li>
<li>threading.Thread</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="PINSoftware.DataSaver.CsvDataSaver.do_single_save"><code class="name flex">
<span>def <span class="ident">do_single_save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_single_save(self):
    &#34;&#34;&#34;.&#34;&#34;&#34;
    new_index = len(self.data.processed_ys)
    for pro_y, pro_times in zip(self.data.processed_ys[self.index:], self.data.processed_timestamps[self.index:]):
        self.csv_file.write(str(pro_times) + &#34;,&#34; + str(pro_y) + &#34;\n&#34;)
    self.index = new_index</code></pre>
</details>
</dd>
<dt id="PINSoftware.DataSaver.CsvDataSaver.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;.&#34;&#34;&#34;
    self.do_single_save()
    self.csv_file.close()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="PINSoftware.DataSaver.BaseDataSaver" href="#PINSoftware.DataSaver.BaseDataSaver">BaseDataSaver</a></b></code>:
<ul class="hlist">
<li><code><a title="PINSoftware.DataSaver.BaseDataSaver.run" href="#PINSoftware.DataSaver.BaseDataSaver.run">run</a></code></li>
<li><code><a title="PINSoftware.DataSaver.BaseDataSaver.stop" href="#PINSoftware.DataSaver.BaseDataSaver.stop">stop</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="PINSoftware.DataSaver.Hdf5DataSaver"><code class="flex name class">
<span>class <span class="ident">Hdf5DataSaver</span></span>
<span>(</span><span>data: <a title="PINSoftware.DataAnalyser.DataAnalyser" href="DataAnalyser.html#PINSoftware.DataAnalyser.DataAnalyser">DataAnalyser</a>, save_folder: str, save_base_filename: str, items: List[str], **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the main saver, it can save all the data in an hdf5 file. The processing parameters are saved as
attributes. It it possible to choose what data is saved using the <code>items</code> argument.</p>
<p><code>data</code> and <code>kwargs</code> are passed to <code><a title="PINSoftware.DataSaver.BaseDataSaver" href="#PINSoftware.DataSaver.BaseDataSaver">BaseDataSaver</a></code>.</p>
<p><code>save_folder</code> and <code>save_base_filename</code> are combined along with a timestamp and extension to form the
<code>full_filename</code>. The file is them opened, if that failed a <code><a title="PINSoftware.DataSaver.SavingException" href="#PINSoftware.DataSaver.SavingException">SavingException</a></code> is raised.</p>
<p><code>items</code> determine what data gets saved. It is a list of strings and if certain strings are in there,
some data gets saved. If it contains "ys" raw data gets saved, "processed_ys" means peak voltages
along with their timestamps, "averaged_processed_ys" means averaged peak voltages and their timestamps.
Finally "markers" means markers and their timestamps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Hdf5DataSaver(BaseDataSaver):
    &#34;&#34;&#34;
    This is the main saver, it can save all the data in an hdf5 file. The processing parameters are saved as
    attributes. It it possible to choose what data is saved using the `items` argument.
    &#34;&#34;&#34;
    def __init__(self, data : DataAnalyser, save_folder : str, save_base_filename : str, items : List[str], **kwargs):
        &#34;&#34;&#34;
        `data` and `kwargs` are passed to `BaseDataSaver`.

        `save_folder` and `save_base_filename` are combined along with a timestamp and extension to form the
        `full_filename`. The file is them opened, if that failed a `SavingException` is raised.

        `items` determine what data gets saved. It is a list of strings and if certain strings are in there,
        some data gets saved. If it contains &#34;ys&#34; raw data gets saved, &#34;processed_ys&#34; means peak voltages
        along with their timestamps, &#34;averaged_processed_ys&#34; means averaged peak voltages and their timestamps.
        Finally &#34;markers&#34; means markers and their timestamps.
        &#34;&#34;&#34;
        full_filename = path.join(save_folder, save_base_filename + datetime.datetime.now().strftime(&#34;%y%m%d-%H%M%S&#34;) + &#34;.hdf5&#34;)
        super().__init__(data, full_filename, **kwargs)
        try:
            self.hdf_file = h5py.File(full_filename, &#39;w&#39;)
            self.debugger.info(&#34;Hdf5DataSaver: Successfully created hdf5 file \&#34;&#34; + full_filename + &#34;\&#34;&#34;)

            self.hdf_file.attrs[&#39;freq&#39;] = self.data.freq
            self.hdf_file.attrs[&#39;edge_detection_threshold&#39;] = self.data.edge_detection_threshold
            self.hdf_file.attrs[&#39;average_count&#39;] = self.data.average_count

            self.hdf_datasets = []
            self.indices = []
            self.data_sources = []

            if &#34;ys&#34; in items:
                self.hdf_datasets.append(self.hdf_file.create_dataset(&#34;ys&#34;, (0,), chunks=True, maxshape=(None,), dtype=&#39;f4&#39;))
                self.indices.append(0)
                self.data_sources.append(self.data.ys)
            if &#34;processed_ys&#34; in items:
                self.hdf_datasets.append(self.hdf_file.create_dataset(&#34;processed_ys&#34;, (0,), chunks=True, maxshape=(None,), dtype=&#39;f4&#39;))
                self.hdf_datasets.append(self.hdf_file.create_dataset(&#34;processed_timestamps&#34;, (0,), chunks=True, maxshape=(None,), dtype=&#39;f8&#39;))
                self.indices.append(0)
                self.indices.append(0)
                self.data_sources.append(self.data.processed_ys)
                self.data_sources.append(self.data.processed_timestamps)
            if &#34;averaged_processed_ys&#34; in items:
                self.hdf_datasets.append(self.hdf_file.create_dataset(&#34;averaged_processed_ys&#34;, (0,), chunks=True, maxshape=(None,), dtype=&#39;f4&#39;))
                self.hdf_datasets.append(self.hdf_file.create_dataset(&#34;averaged_processed_timestamps&#34;, (0,), chunks=True, maxshape=(None,), dtype=&#39;f8&#39;))
                self.indices.append(0)
                self.indices.append(0)
                self.data_sources.append(self.data.averaged_processed_ys)
                self.data_sources.append(self.data.averaged_processed_timestamps)
            if &#34;markers&#34; in items:
                self.hdf_datasets.append(self.hdf_file.create_dataset(&#34;markers&#34;, (0,), chunks=True, maxshape=(None,), dtype=&#39;f4&#39;))
                self.hdf_datasets.append(self.hdf_file.create_dataset(&#34;marker_timestamps&#34;, (0,), chunks=True, maxshape=(None,), dtype=&#39;f8&#39;))
                self.indices.append(0)
                self.indices.append(0)
                self.data_sources.append(self.data.markers)
                self.data_sources.append(self.data.marker_timestamps)
        except:
            raise SavingException(&#34;Could not open file \&#34;&#34; + full_filename + &#34;\&#34; to log data in.&#34;)

    def do_single_save(self):
        &#34;&#34;&#34;.&#34;&#34;&#34;
        new_indices = [len(source) for source in self.data_sources]
        for dataset, index, source, new_index in zip(self.hdf_datasets, self.indices, self.data_sources, new_indices):
            dataset.resize((new_index,))
            dataset[index:new_index] = source[index:new_index]
        self.indices = new_indices

    def close(self):
        &#34;&#34;&#34;.&#34;&#34;&#34;
        self.hdf_file.close()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="PINSoftware.DataSaver.BaseDataSaver" href="#PINSoftware.DataSaver.BaseDataSaver">BaseDataSaver</a></li>
<li>threading.Thread</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="PINSoftware.DataSaver.Hdf5DataSaver.do_single_save"><code class="name flex">
<span>def <span class="ident">do_single_save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_single_save(self):
    &#34;&#34;&#34;.&#34;&#34;&#34;
    new_indices = [len(source) for source in self.data_sources]
    for dataset, index, source, new_index in zip(self.hdf_datasets, self.indices, self.data_sources, new_indices):
        dataset.resize((new_index,))
        dataset[index:new_index] = source[index:new_index]
    self.indices = new_indices</code></pre>
</details>
</dd>
<dt id="PINSoftware.DataSaver.Hdf5DataSaver.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;.&#34;&#34;&#34;
    self.hdf_file.close()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="PINSoftware.DataSaver.BaseDataSaver" href="#PINSoftware.DataSaver.BaseDataSaver">BaseDataSaver</a></b></code>:
<ul class="hlist">
<li><code><a title="PINSoftware.DataSaver.BaseDataSaver.run" href="#PINSoftware.DataSaver.BaseDataSaver.run">run</a></code></li>
<li><code><a title="PINSoftware.DataSaver.BaseDataSaver.stop" href="#PINSoftware.DataSaver.BaseDataSaver.stop">stop</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="PINSoftware" href="index.html">PINSoftware</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="PINSoftware.DataSaver.Filetype" href="#PINSoftware.DataSaver.Filetype">Filetype</a></code></h4>
<ul class="">
<li><code><a title="PINSoftware.DataSaver.Filetype.Csv" href="#PINSoftware.DataSaver.Filetype.Csv">Csv</a></code></li>
<li><code><a title="PINSoftware.DataSaver.Filetype.Hdf5" href="#PINSoftware.DataSaver.Filetype.Hdf5">Hdf5</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="PINSoftware.DataSaver.SavingException" href="#PINSoftware.DataSaver.SavingException">SavingException</a></code></h4>
</li>
<li>
<h4><code><a title="PINSoftware.DataSaver.BaseDataSaver" href="#PINSoftware.DataSaver.BaseDataSaver">BaseDataSaver</a></code></h4>
<ul class="">
<li><code><a title="PINSoftware.DataSaver.BaseDataSaver.do_single_save" href="#PINSoftware.DataSaver.BaseDataSaver.do_single_save">do_single_save</a></code></li>
<li><code><a title="PINSoftware.DataSaver.BaseDataSaver.close" href="#PINSoftware.DataSaver.BaseDataSaver.close">close</a></code></li>
<li><code><a title="PINSoftware.DataSaver.BaseDataSaver.run" href="#PINSoftware.DataSaver.BaseDataSaver.run">run</a></code></li>
<li><code><a title="PINSoftware.DataSaver.BaseDataSaver.stop" href="#PINSoftware.DataSaver.BaseDataSaver.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="PINSoftware.DataSaver.CsvDataSaver" href="#PINSoftware.DataSaver.CsvDataSaver">CsvDataSaver</a></code></h4>
<ul class="">
<li><code><a title="PINSoftware.DataSaver.CsvDataSaver.do_single_save" href="#PINSoftware.DataSaver.CsvDataSaver.do_single_save">do_single_save</a></code></li>
<li><code><a title="PINSoftware.DataSaver.CsvDataSaver.close" href="#PINSoftware.DataSaver.CsvDataSaver.close">close</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="PINSoftware.DataSaver.Hdf5DataSaver" href="#PINSoftware.DataSaver.Hdf5DataSaver">Hdf5DataSaver</a></code></h4>
<ul class="">
<li><code><a title="PINSoftware.DataSaver.Hdf5DataSaver.do_single_save" href="#PINSoftware.DataSaver.Hdf5DataSaver.do_single_save">do_single_save</a></code></li>
<li><code><a title="PINSoftware.DataSaver.Hdf5DataSaver.close" href="#PINSoftware.DataSaver.Hdf5DataSaver.close">close</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>